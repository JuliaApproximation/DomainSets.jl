var documenterSearchIndex = {"docs":
[{"location":"numbers/#Sets-of-numbers","page":"Numbers","title":"Sets of numbers","text":"","category":"section"},{"location":"numbers/","page":"Numbers","title":"Numbers","text":"DomainSets has specific types that represent common sets of numbers.","category":"page"},{"location":"numbers/","page":"Numbers","title":"Numbers","text":"ℕ\nℤ\nℚ\nℝ\nℂ\nℝ1\nℝ2\nℝ3\nℝ4","category":"page"},{"location":"numbers/#DomainSets.ℕ-numbers","page":"Numbers","title":"DomainSets.ℕ","text":"The set of natural numbers.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℤ-numbers","page":"Numbers","title":"DomainSets.ℤ","text":"The set of integers.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℚ-numbers","page":"Numbers","title":"DomainSets.ℚ","text":"The set of rational numbers.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℝ-numbers","page":"Numbers","title":"DomainSets.ℝ","text":"The set of real numbers.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℂ-numbers","page":"Numbers","title":"DomainSets.ℂ","text":"The set of complex numbers.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℝ1-numbers","page":"Numbers","title":"DomainSets.ℝ1","text":"The Euclidean space ℝ^1.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℝ2-numbers","page":"Numbers","title":"DomainSets.ℝ2","text":"The Euclidean space ℝ^2.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℝ3-numbers","page":"Numbers","title":"DomainSets.ℝ3","text":"The Euclidean space ℝ^3.\n\n\n\n\n\n","category":"constant"},{"location":"numbers/#DomainSets.ℝ4-numbers","page":"Numbers","title":"DomainSets.ℝ4","text":"The Euclidean space ℝ^4.\n\n\n\n\n\n","category":"constant"},{"location":"interface/#The-domain-interface","page":"The domain interface","title":"The domain interface","text":"","category":"section"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"Existing types may add the interpretation of being a domain by implementing the domain interface. They gain the ability to interact with other domains.","category":"page"},{"location":"interface/#The-in-function","page":"The domain interface","title":"The in function","text":"","category":"section"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"A domain is a set of elements that is possibly continuous. Continuous sets are defined mathematically, not by an exhaustive list of their elements. In practice membership of the set is defined by the implementation of in. The function call in(x, domain) evaluates to true if the domain contains an element y such that y == x.","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"note: Note\nIncompatible element types. In principle, the function in(x, domain) should not throw an exception even if the types seem mathematically nonsensical. In that case, the correct return value is false. This mimicks the behaviour of in for finite sets in Julia:julia> in(rand(3,3), 1:3)\nfalseIndeed, a 3x3 matrix is not equal to any of the numbers 1, 2 or 3.","category":"page"},{"location":"interface/#The-domaineltype-function","page":"The domain interface","title":"The domaineltype function","text":"","category":"section"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"The defining mathematical condition of a continuous set might be satisfied by variables of different types. Still, the interface defines the domaineltype of a domain. It is a valid type for elements of the set.","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"Functions that generate elements of the domain should generate elements of that type. As a consequence, for finite sets such as an AbstractArray or AbstractSet, the domaineltype agrees with the eltype of that set. For intervals on the real line, the domaineltype might be Float64. When there is no clear candidate the domaineltype might simply be Any.","category":"page"},{"location":"interface/#Minimal-formal-interface","page":"The domain interface","title":"Minimal formal interface","text":"","category":"section"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"The domain interface is formally summarised in the following table:","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"Required methods  Brief description\nin(x, d)  Returns true when x is an element of the domain, false otherwise\nDomainStyle(d)  Returns IsDomain() if d implements this interface\nOptional methods Default definition Brief description\ndomaineltype(d) eltype(d) Returns a valid type for elements of the domain","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"Several extensions of this minimal interface are defined in the DomainSets package.","category":"page"},{"location":"interface/#The-Domain-supertype-and-DomainStyle-trait","page":"The domain interface","title":"The Domain supertype and DomainStyle trait","text":"","category":"section"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"Domains in this package inherit from the abstract type Domain{T}. It is the supertype of continuous sets with domaineltype equal to T.","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"The package also defines the trait DomainStyle. Any type can declare to implement the domain interface by defining","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"DomainSets.DomainStyle(d::MyDomain) = IsDomain()","category":"page"},{"location":"interface/","page":"The domain interface","title":"The domain interface","text":"Objects of type Number, AbstractArray and AbstractSet are declared to be domains in this package.","category":"page"},{"location":"canonical/#Canonical-domains","page":"Canonical domains","title":"Canonical domains","text":"","category":"section"},{"location":"setoperations/#Set-operations","page":"Set operations","title":"Set operations","text":"","category":"section"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"DomainSets implements a number of standard set operations. In some cases the operation can be performed analytically and a concrete domain is returned. More often than not, however, the operation results in a lazy structure.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"Functions like uniondomain and intersectdomain are not restricted to arguments of type Domain. Thus, one can construct the lazy union of any two objects, regardless of their types.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"A distinction is made for set operations between functions in lowercase, such as uniondomain, and capitalized functions, in this case UnionDomain. The former attempts to simplify the arguments (see Canonical domains) and returns a domain that is mathematically equivalent to the union of the two domains. The latter is the constructor of a type and hence always returns an instance of UnionDomain.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"note: Note\nFor concrete subtypes of Domain one can use standard Julia operators and functions for common set operations. The relevant symbols and functions are ∪ (union), ∩ (intersect) and ∖ (setdiff). For example:julia> UnitBall(3) ∩ Point([0,0,0])\nPoint([0.0, 0.0, 0.0])","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"warning: Warning\nSet operations in DomainSets are often not type-stable. For example, by convention uniondomain(d1,d2) returns a domain of the simplest type that is mathematically equivalent to the union of d1 and d2. The union of two overlapping intervals is a single interval, but the union of non-overlapping intervals is a UnionDomain:julia> uniondomain(1..3, 2..4)\n1 .. 4\njulia> uniondomain(1..3, 5..7)\n(1 .. 3) ∪ (5 .. 7)When type-safety is important, use the corresponding constructor:julia> UnionDomain(1..3, 2..4)\n(1 .. 3) ∪ (2 .. 4)","category":"page"},{"location":"setoperations/#Product-domains","page":"Set operations","title":"Product domains","text":"","category":"section"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"Product domains are created most easily by invoking the ProductDomain constructor. The constructor of the associated abstract type ProductDomain returns an instance of a suitable concrete subtype. In many cases a user need not be aware of which type is being returned by ProductDomain, as it always behaves like the requested domain.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"ProductDomain()","category":"page"},{"location":"setoperations/#DomainSets.ProductDomain-Tuple{}-setoperations","page":"Set operations","title":"DomainSets.ProductDomain","text":"ProductDomain(domains...)\nProductDomain{T}(domains...)\n\nReturn a concrete subtype of ProductDomain which agrees mathematically with the cartesian product of the given domains.\n\nThe concrete subtype being returned depends on T. If T is provided, it will be the eltype of the product domain. If T is not provided, a suitable choice is deduced from the arguments.\n\nSee also: VcatDomain, VectorProductDomain, TupleProductDomain, Rectangle(a,b).\n\n\n\n\n\n","category":"method"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"A number of concrete product domain types are implemented. They differ in what the eltype of the product domain is. In the most generic case T is a tuple, with each element representing the element type of the corresponding factor. A VcatDomain is a special case for product domains of Euclidean type, i.e., one in which each factor has a scalar or statically-sized vector as element type. Finally, a VectorProductDomain has a Vector element type whose dimension is determined by the number of factors. The ProductDomain aims to return the most specialized type of domain, but the individual constructors may be invoked to ensure a specific one.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"julia> ProductDomain(2..4.5, 3.0..5.0)\n(2.0 .. 4.5) × (3.0 .. 5.0)\n\njulia> eltype(ProductDomain(2..4.5, 3.0..5.0))\nSVector{2, Float64}\n\njulia> [2.4, 4] ∈ ProductDomain(2..4.5, 3.0..5.0)\ntrue\n\njulia> TupleProductDomain(2..4.5, 3.0..5.0)\n(2.0 .. 4.5) × (3.0 .. 5.0)\n\njulia> eltype(TupleProductDomain(2..4.5, 3.0..5.0))\nTuple{Float64, Float64}\n\njulia> (2.4, 4) ∈ TupleProductDomain(2..4.5, 3.0..5.0)\ntrue\n\njulia> ProductDomain([ i..i+1.0 for i in 1:10])\n(1.0 .. 2.0) × (2.0 .. 3.0) × (3.0 .. 4.0) × ... × (10.0 .. 11.0)\n\njulia> eltype(ProductDomain([ i..i+1.0 for i in 1:10]))\nVector{Float64}\n\njulia> 1:10 ∈ ProductDomain([ i..i+1.0 for i in 1:10])\ntrue","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"It is noteworthy that a VcatDomain can cope with the concatenation of scalars and vectors. In the example below, a cylinder is represented as the product of a two-dimensional disk with a one-dimensional interval.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"julia> using DomainSets: ×\n\njulia> cylinder = UnitDisk() × UnitInterval()\nUnitDisk() × (0.0 .. 1.0 (Unit))\n\njulia> eltype(cylinder)\nSVector{3, Float64}\n\njulia> [0.4,0.2,0.6] ∈ cylinder\ntrue","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"A number of concrete product domains are implemented in DomainSets.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"VcatDomain\nVectorProductDomain\nTupleProductDomain\nRectangle","category":"page"},{"location":"setoperations/#DomainSets.VcatDomain-setoperations","page":"Set operations","title":"DomainSets.VcatDomain","text":"A VcatDomain concatenates the element types of its member domains in a single static vector.\n\n\n\n\n\n","category":"type"},{"location":"setoperations/#DomainSets.VectorProductDomain-setoperations","page":"Set operations","title":"DomainSets.VectorProductDomain","text":"A VectorProductDomain is a product domain of arbitrary dimension where the element type is a vector, and all member domains have the same element type.\n\n\n\n\n\n","category":"type"},{"location":"setoperations/#DomainSets.TupleProductDomain-setoperations","page":"Set operations","title":"DomainSets.TupleProductDomain","text":"A TupleProductDomain is a product domain that concatenates the elements of its member domains in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"setoperations/#DomainSets.Rectangle-setoperations","page":"Set operations","title":"DomainSets.Rectangle","text":"Rectangle(a, b)\nRectangle(domains::ClosedInterval...)\nRectangle{T}(domains::ClosedInterval...)\n\nA rectangular domain in n dimensions with extrema determined by the vectors or points a and b or by the endpoints of the given intervals.\n\n\n\n\n\n","category":"type"},{"location":"setoperations/#Union-of-sets","page":"Set operations","title":"Union of sets","text":"","category":"section"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"The mathematical union of two sets is guaranteed by uniondomain, while a lazy union is returned by UnionDomain.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"For vectors and sets in Julia, uniondomain returns precisely what the standard union operation would do, while UnionDomain returns a lazy construct:","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"julia> uniondomain(1:3, 10)\n4-element Vector{Int64}:\n  1\n  2\n  3\n 10\njulia> UnionDomain(1:3, 10)\n1:3 ∪ 10\n\njulia> 10 ∈ ans\ntrue","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"uniondomain\nUnionDomain","category":"page"},{"location":"setoperations/#DomainSets.uniondomain-setoperations","page":"Set operations","title":"DomainSets.uniondomain","text":"uniondomain(domains...)\n\nReturn a domain that agrees with the mathematical union of the arguments.\n\nSee also: UnionDomain.\n\n\n\n\n\n","category":"function"},{"location":"setoperations/#DomainSets.UnionDomain-setoperations","page":"Set operations","title":"DomainSets.UnionDomain","text":"UnionDomain(domains...)\nUnionDomain{T}(domains...)\n\nThe lazy union of the given domains.\n\nSee also: uniondomain.\n\n\n\n\n\n","category":"type"},{"location":"setoperations/#Set-intersection","page":"Set operations","title":"Set intersection","text":"","category":"section"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"The mathematical intersection of two sets is guaranteed by intersectdomain, while a lazy intersection is returned by IntersectDomain.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"intersectdomain\nIntersectDomain","category":"page"},{"location":"setoperations/#DomainSets.intersectdomain-setoperations","page":"Set operations","title":"DomainSets.intersectdomain","text":"intersectdomain(domains...)\n\nReturn a domain which agrees with the mathematical intersection of the given domains.\n\nSee also: IntersectDomain.\n\n\n\n\n\n","category":"function"},{"location":"setoperations/#DomainSets.IntersectDomain-setoperations","page":"Set operations","title":"DomainSets.IntersectDomain","text":"IntersectDomain(domains...)\nIntersectDomain{T}(domains...)\n\nThe lazy intersection of an iterable list of domains.\n\nSee also: intersectdomain.\n\n\n\n\n\n","category":"type"},{"location":"setoperations/#Set-difference","page":"Set operations","title":"Set difference","text":"","category":"section"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"The mathematical difference of two sets is guaranteed by setdiffdomain, while a lazy difference is returned by SetdiffDomain.","category":"page"},{"location":"setoperations/","page":"Set operations","title":"Set operations","text":"setdiffdomain\nSetdiffDomain","category":"page"},{"location":"setoperations/#DomainSets.setdiffdomain-setoperations","page":"Set operations","title":"DomainSets.setdiffdomain","text":"setdiffdomain(d1, d2)\n\nReturn a domain which agrees with the mathematical difference of the given domains.\n\nSee also: SetdiffDomain.\n\n\n\n\n\n","category":"function"},{"location":"setoperations/#DomainSets.SetdiffDomain-setoperations","page":"Set operations","title":"DomainSets.SetdiffDomain","text":"SetdiffDomain(d1, d2)\nSetdiffDomain{T}(d1, d2)\n\nThe lazy set difference of the given domains.\n\nSee also: setdiffdomain.\n\n\n\n\n\n","category":"type"},{"location":"complex/#Complex-analysis","page":"Complex analysis","title":"Complex analysis","text":"","category":"section"},{"location":"complex/#Regions-of-the-complex-plane","page":"Complex analysis","title":"Regions of the complex plane","text":"","category":"section"},{"location":"complex/","page":"Complex analysis","title":"Complex analysis","text":"A number of domains relate to the complex plane:","category":"page"},{"location":"complex/","page":"Complex analysis","title":"Complex analysis","text":"ComplexUnitCircle\nComplexUnitDisk","category":"page"},{"location":"complex/","page":"Complex analysis","title":"Complex analysis","text":"For a more specific package dealing with complex regions, see ComplexRegions.jl.","category":"page"},{"location":"complex/#Identification-with-the-plane","page":"Complex analysis","title":"Identification with the plane","text":"","category":"section"},{"location":"complex/","page":"Complex analysis","title":"Complex analysis","text":"Any domain in ℝ^2 can be identified with a region of the complex plane. The relevant maps to use are FunctionMaps.VectorToComplex and FunctionMaps.ComplexToVector.","category":"page"},{"location":"complex/","page":"Complex analysis","title":"Complex analysis","text":"FunctionMaps.VectorToComplex\nFunctionMaps.ComplexToVector","category":"page"},{"location":"complex/#DomainSets.FunctionMaps.VectorToComplex-complex","page":"Complex analysis","title":"DomainSets.FunctionMaps.VectorToComplex","text":"VectorToComplex()\nVectorToComplex{T}()\n\nThe map ab  a+bi from ℝ^2 to ℂ.\n\nSee also: FunctionMaps.ComplexToVector.\n\n\n\n\n\n","category":"type"},{"location":"complex/#DomainSets.FunctionMaps.ComplexToVector-complex","page":"Complex analysis","title":"DomainSets.FunctionMaps.ComplexToVector","text":"ComplexToVector()\nComplexToVector{T}()\n\nMap a complex number z=a+bi to the length 2 vector a b.\n\nSee also: FunctionMaps.VectorToComplex.\n\n\n\n\n\n","category":"type"},{"location":"api/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"This is an exhaustive list of all exported modules, constants, types, functions and macros in DomainSets.jl.","category":"page"},{"location":"api/#Constants","page":"Public API Reference","title":"Constants","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [DomainSets]\nOrder   = [:constant]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#DomainSets.AnyDomain","page":"Public API Reference","title":"DomainSets.AnyDomain","text":"AnyDomain is the union of Domain and DomainRef.\n\nIn both cases domain(d::AnyDomain) returns the domain itself.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ℂ","page":"Public API Reference","title":"DomainSets.ℂ","text":"The set of complex numbers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℕ","page":"Public API Reference","title":"DomainSets.ℕ","text":"The set of natural numbers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℚ","page":"Public API Reference","title":"DomainSets.ℚ","text":"The set of rational numbers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℝ","page":"Public API Reference","title":"DomainSets.ℝ","text":"The set of real numbers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℝ1","page":"Public API Reference","title":"DomainSets.ℝ1","text":"The Euclidean space ℝ^1.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℝ2","page":"Public API Reference","title":"DomainSets.ℝ2","text":"The Euclidean space ℝ^2.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℝ3","page":"Public API Reference","title":"DomainSets.ℝ3","text":"The Euclidean space ℝ^3.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℝ4","page":"Public API Reference","title":"DomainSets.ℝ4","text":"The Euclidean space ℝ^4.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DomainSets.ℤ","page":"Public API Reference","title":"DomainSets.ℤ","text":"The set of integers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Functions","page":"Public API Reference","title":"Functions","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [DomainSets]\nOrder   = [:function]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#DomainSets.approx_in-Tuple{Any, Any}","page":"Public API Reference","title":"DomainSets.approx_in","text":"approx_in(x, domain::Domain [, tolerance])\n\nVerify whether a point lies in the given domain with a certain tolerance.\n\nThe tolerance has to be positive. The meaning of the tolerance, in relation to the possible distance of the point to the domain, is domain-dependent. Usually, if the outcome is true, it means that the distance of the point to the domain is smaller than a constant times the tolerance. That constant may depend on the domain.\n\nUp to inexact computations due to floating point numbers, it should also be the case that approx_in(x, d, 0) == in(x,d). This implies that approx_in reflects whether a domain is open or closed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.boundary","page":"Public API Reference","title":"DomainSets.boundary","text":"Return the boundary of the given domain as a domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#DomainSets.boundingbox-Tuple{Any}","page":"Public API Reference","title":"DomainSets.boundingbox","text":"Return a bounding box of the given domain.\n\nA bounding box is an interval, a hyperrectangle or the full space. It is such that each point in the domain also lies in the bounding box.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.canonicaldomain-Tuple{Any}","page":"Public API Reference","title":"DomainSets.canonicaldomain","text":"canonicaldomain([ctype::CanonicalType, ]domain)\n\nReturn an associated canonical domain, if any, of the given domain.\n\nFor example, the canonical domain of an Interval [a,b] is the interval [-1,1].\n\nOptionally, a canonical type argument may specify an alternative canonical domain. Canonical domains help with establishing equality between domains, with finding maps between domains and with finding parameterizations.\n\nIf a domain implements a canonical domain, it should also implement mapfrom_canonical and mapto_canonical.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.checkdomain-Tuple{Domain}","page":"Public API Reference","title":"DomainSets.checkdomain","text":"checkdomain(d)\n\nChecks that d is a domain or refers to a domain and if so returns that domain, throws an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.choice-Tuple{Any}","page":"Public API Reference","title":"DomainSets.choice","text":"Return a point from the given domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.corners-Tuple{DomainSets.HyperRectangle}","page":"Public API Reference","title":"DomainSets.corners","text":"Return all corners of the domain in a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.cylinder-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Public API Reference","title":"DomainSets.cylinder","text":"Create a cylinder with given radius and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.dimension-Tuple{Any}","page":"Public API Reference","title":"DomainSets.dimension","text":"What is the Euclidean dimension of the domain?\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.distance_to","page":"Public API Reference","title":"DomainSets.distance_to","text":"distance_to(d, x)\n\nReturn the distance from the point x to the domain d.\n\n\n\n\n\n","category":"function"},{"location":"api/#DomainSets.domain-Tuple{Domain}","page":"Public API Reference","title":"DomainSets.domain","text":"domain(d)\n\nReturn a domain associated with the object d.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.domaineltype-Tuple{Any}","page":"Public API Reference","title":"DomainSets.domaineltype","text":"domaineltype(d)\n\nThe domaineltype of a continuous set is a valid type for elements of that set. By default it is equal to the eltype of d, which in turn defaults to Any.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.ellipse-Tuple{Number, Number}","page":"Public API Reference","title":"DomainSets.ellipse","text":"Create an ellipse curve with semi-axes lengths a and b respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.ellipse_shape-Tuple{Number, Number}","page":"Public API Reference","title":"DomainSets.ellipse_shape","text":"Create an ellipse-shaped domain with semi-axes lengths a and b respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.emptyspace-Tuple{Any}","page":"Public API Reference","title":"DomainSets.emptyspace","text":"Return the empty space with the same element type as the given domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.equaldomain-Tuple{Any}","page":"Public API Reference","title":"DomainSets.equaldomain","text":"Return a canonical domain that is equal, but simpler. For example, a 1-dimensional ball is an interval.\n\nA domain and its equaldomain are always equal domains according to isequaldomain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.fullspace-Tuple{Any}","page":"Public API Reference","title":"DomainSets.fullspace","text":"Return the full space with the same element type as the given domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.hascanonicaldomain-Tuple{Any}","page":"Public API Reference","title":"DomainSets.hascanonicaldomain","text":"Does the domain have a canonical domain?\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.hasparameterization-Tuple{Any}","page":"Public API Reference","title":"DomainSets.hasparameterization","text":"Does the domain have a parameterization?\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.intersectdomain-Tuple{}","page":"Public API Reference","title":"DomainSets.intersectdomain","text":"intersectdomain(domains...)\n\nReturn a domain which agrees with the mathematical intersection of the given domains.\n\nSee also: IntersectDomain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.isequaldomain-Tuple{Any, Any}","page":"Public API Reference","title":"DomainSets.isequaldomain","text":"isequaldomain(d1, d2)\n\nAre the two given domains equal?\n\nDomains are considered equal if their membership functions return the same output for the same input.\n\nIt is not always possible to verify this automatically. If the result is true, then the domains are guaranteed to be equal. If the result is false, then either the domains are not equal or they are equal but the implementation fails to recognize this.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.map_domain-Tuple{Any, Any}","page":"Public API Reference","title":"DomainSets.map_domain","text":"Map a domain with the inverse of the given map.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.mapfrom_canonical-Tuple{Any}","page":"Public API Reference","title":"DomainSets.mapfrom_canonical","text":"mapfrom_canonical(d[, x])\n\nReturn a map to a domain d from its canonical domain.\n\nIf a second argument x is given, the map is evaluated at that point. The point x should be a point in the canonical domain of d, and the result is a point in d.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.mapped_domain-Tuple{Any, Any}","page":"Public API Reference","title":"DomainSets.mapped_domain","text":"Make a mapped domain with the given inverse map.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.mapto-Tuple{Any, Any}","page":"Public API Reference","title":"DomainSets.mapto","text":"Return a map from domain d1 to domain d2.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.mapto_canonical-Tuple{Any}","page":"Public API Reference","title":"DomainSets.mapto_canonical","text":"Return a map from the domain to its canonical domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.normal","page":"Public API Reference","title":"DomainSets.normal","text":"Return the normal of the domain at the point x.\n\nIt is assumed that x is a point on the boundary of the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#DomainSets.parameterdomain-Tuple{Any}","page":"Public API Reference","title":"DomainSets.parameterdomain","text":"Return a parameter domain which supports a parameterization.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.parameterization-Tuple{Any}","page":"Public API Reference","title":"DomainSets.parameterization","text":"Return a parameterization of the given domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.setdiffdomain-Tuple{Any, Any}","page":"Public API Reference","title":"DomainSets.setdiffdomain","text":"setdiffdomain(d1, d2)\n\nReturn a domain which agrees with the mathematical difference of the given domains.\n\nSee also: SetdiffDomain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.tangents","page":"Public API Reference","title":"DomainSets.tangents","text":"Return the tangents of the domain at the point x. The tangents form a basis for the tangent plane, perpendicular to the normal direction at x.\n\n\n\n\n\n","category":"function"},{"location":"api/#DomainSets.typedomain-Tuple{Any}","page":"Public API Reference","title":"DomainSets.typedomain","text":"Return the domain for the element type of the given domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.uniondomain-Tuple{}","page":"Public API Reference","title":"DomainSets.uniondomain","text":"uniondomain(domains...)\n\nReturn a domain that agrees with the mathematical union of the arguments.\n\nSee also: UnionDomain.\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.volume","page":"Public API Reference","title":"DomainSets.volume","text":"Return the volume of the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"Public API Reference","title":"Types","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [DomainSets]\nOrder   = [:type]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#DomainSets.Ball","page":"Public API Reference","title":"DomainSets.Ball","text":"Supertype of balls for which elements satisfy norm(x) < radius(ball) (open ball) or norm(x) <= radius(ball) (closed ball).\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.Ball-Tuple{}","page":"Public API Reference","title":"DomainSets.Ball","text":"Ball(radius = 1[, center])\nBall{T,C=:closed}(radius = 1[, center])\n\nReturn a concrete subtype of Ball which represents a ball with the given radius and center, the given eltype T, and which is open or closed.\n\nThe default center is the origin. In case both radius and center are omitted, a subtype of UnitBall is returned, whose concrete type depends on T.\n\nA ball represents a volume. For the boundary of a ball, see Sphere().\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.ChebyshevInterval","page":"Public API Reference","title":"DomainSets.ChebyshevInterval","text":"ChebyshevInterval()\nChebyshevInterval{T=Float64}()\n\nThe closed interval [-1,1].\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ComplexNumbers","page":"Public API Reference","title":"DomainSets.ComplexNumbers","text":"The set of all complex numbers whose real and imaginary parts are real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ComplexUnitCircle","page":"Public API Reference","title":"DomainSets.ComplexUnitCircle","text":"ComplexUnitCircle()\nComplexUnitCircle{T}()\n\nThe unit circle in the complex plane.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ComplexUnitDisk","page":"Public API Reference","title":"DomainSets.ComplexUnitDisk","text":"ComplexUnitDisk()\nComplexUnitDisk{T}()\nComplexUnitDisk{T,C}()\n\nThe unit disk in the complex plane. The disk is open when C=:open and closed when C=:closed.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.DomainRef","page":"Public API Reference","title":"DomainSets.DomainRef","text":"DomainRef(d)\n\nA reference to a domain.\n\nIn a function call, DomainRef(x) can be used to indicate that x should be treated as a domain, e.g., foo(x, DomainRef(d)).\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.DomainStyle","page":"Public API Reference","title":"DomainSets.DomainStyle","text":"DomainStyle(d)\n\nTrait to indicate whether or not d implements the domain interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.DynamicUnitBall","page":"Public API Reference","title":"DomainSets.DynamicUnitBall","text":"DynamicUnitBall(dim::Int)\nDynamicUnitBall{T}(dim::Int)\nDynamicUnitBall{T,C=:closed}(dim::Int)\n\nThe open or closed unit ball with variable dimension. Typically the element type is a Vector{T} and dim specifies the length of the vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.DynamicUnitCube","page":"Public API Reference","title":"DomainSets.DynamicUnitCube","text":"A unit cube whose dimension is specified by a field.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.DynamicUnitSimplex","page":"Public API Reference","title":"DomainSets.DynamicUnitSimplex","text":"A unit simplex with vector elements with variable dimension determined by a field.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.DynamicUnitSphere","page":"Public API Reference","title":"DomainSets.DynamicUnitSphere","text":"The unit sphere with variable dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.EmptySpace","page":"Public API Reference","title":"DomainSets.EmptySpace","text":"The empty space.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.EuclideanDomain","page":"Public API Reference","title":"DomainSets.EuclideanDomain","text":"A EuclideanDomain is any domain whose eltype is <:StaticVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.EuclideanUnitBall","page":"Public API Reference","title":"DomainSets.EuclideanUnitBall","text":"The unit ball in a fixed N-dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.EuclideanUnitCube","page":"Public API Reference","title":"DomainSets.EuclideanUnitCube","text":"The unit cube in a fixed N-dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.EuclideanUnitSphere","page":"Public API Reference","title":"DomainSets.EuclideanUnitSphere","text":"The unit sphere in a fixed N-dimensional Euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.FullSpace","page":"Public API Reference","title":"DomainSets.FullSpace","text":"A domain that represents the full space.\n\nThe element type T in FullSpace{T} should only be seen as an indication of the expected types of the elements in the context where the domain is intended to be used. Due to the default, loose interpretation of T, any FullSpace{T} actually contains any x regardless of the type of x. For a strict domain of all elements of type T, or elements convertible exactly to T, use TypeDomain{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.HalfLine","page":"Public API Reference","title":"DomainSets.HalfLine","text":"HalfLine()\nHalfLine{T=Float64,C=:closed}()\n\nThe positive halfline [0,∞) when C is :closed or (0,∞) when C is :open. The interval is always open at infinity.\n\nSee also: NonnegativeRealLine, PositiveRealLine.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.IndicatorFunction","page":"Public API Reference","title":"DomainSets.IndicatorFunction","text":"An IndicatorFunction is a domain that implements f(x) = x ∈ D by storing f.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.Integers","page":"Public API Reference","title":"DomainSets.Integers","text":"The set of all integers.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.IntersectDomain","page":"Public API Reference","title":"DomainSets.IntersectDomain","text":"IntersectDomain(domains...)\nIntersectDomain{T}(domains...)\n\nThe lazy intersection of an iterable list of domains.\n\nSee also: intersectdomain.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.IsDomain","page":"Public API Reference","title":"DomainSets.IsDomain","text":"IsDomain()\n\nindicates an object implements the domain interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.LevelSet","page":"Public API Reference","title":"DomainSets.LevelSet","text":"The domain defined by f(x)=C for a given function f and constant C.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.MappedDomain","page":"Public API Reference","title":"DomainSets.MappedDomain","text":"A MappedDomain stores the inverse map of a mapped domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.NegativeHalfLine","page":"Public API Reference","title":"DomainSets.NegativeHalfLine","text":"NegativeHalfLine()\nNegativeHalfLine{T=Float64,C=:closed}()\n\nThe negative halfline (-∞,0] when C is :closed or (-∞,0) when C is :open. The interval is always open at minus infinity.\n\nSee also: NonpositiveRealLine, NegativeRealLine.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.NotDomain","page":"Public API Reference","title":"DomainSets.NotDomain","text":"NotDomain()\n\nindicates an object does not implement the domain interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.Point","page":"Public API Reference","title":"DomainSets.Point","text":"Point(x)\n\nrepresents a single point at x.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ProductDomain","page":"Public API Reference","title":"DomainSets.ProductDomain","text":"abstract type ProductDomain{T}\n\nA ProductDomain represents the cartesian product of other domains.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ProductDomain-Tuple{}","page":"Public API Reference","title":"DomainSets.ProductDomain","text":"ProductDomain(domains...)\nProductDomain{T}(domains...)\n\nReturn a concrete subtype of ProductDomain which agrees mathematically with the cartesian product of the given domains.\n\nThe concrete subtype being returned depends on T. If T is provided, it will be the eltype of the product domain. If T is not provided, a suitable choice is deduced from the arguments.\n\nSee also: VcatDomain, VectorProductDomain, TupleProductDomain, Rectangle(a,b).\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.Rationals","page":"Public API Reference","title":"DomainSets.Rationals","text":"The set of all rationals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.RealLine","page":"Public API Reference","title":"DomainSets.RealLine","text":"The real line (-∞,∞).\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.RealNumbers","page":"Public API Reference","title":"DomainSets.RealNumbers","text":"The set of all real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.Rectangle","page":"Public API Reference","title":"DomainSets.Rectangle","text":"Rectangle(a, b)\nRectangle(domains::ClosedInterval...)\nRectangle{T}(domains::ClosedInterval...)\n\nA rectangular domain in n dimensions with extrema determined by the vectors or points a and b or by the endpoints of the given intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.SetdiffDomain","page":"Public API Reference","title":"DomainSets.SetdiffDomain","text":"SetdiffDomain(d1, d2)\nSetdiffDomain{T}(d1, d2)\n\nThe lazy set difference of the given domains.\n\nSee also: setdiffdomain.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.Sphere","page":"Public API Reference","title":"DomainSets.Sphere","text":"Supertype of spherical domains for which elements satisfy norm(x) == radius(sphere).\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.Sphere-Tuple{}","page":"Public API Reference","title":"DomainSets.Sphere","text":"Sphere(radius = 1[, center])\nSphere{T}(radius = 1[, center])\n\nReturn a concrete subtype of Sphere which represents a sphere with the given radius and center, and the given eltype T.\n\nThe default center is the origin. In case both radius and center are omitted, a subtype of UnitSphere is returned, whose concrete type depends on T.\n\nA sphere represents the boundary of a ball. For the volume, see Ball().\n\n\n\n\n\n","category":"method"},{"location":"api/#DomainSets.StaticUnitBall","page":"Public API Reference","title":"DomainSets.StaticUnitBall","text":"StaticUnitBall()\nStaticUnitBall{T}()\nStaticUnitBall{T,C=:closed}()\n\nThe open or closed unit ball with static dimension determined by the element type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.StaticUnitCube","page":"Public API Reference","title":"DomainSets.StaticUnitCube","text":"A unit cube that is specified by the element type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.StaticUnitSimplex","page":"Public API Reference","title":"DomainSets.StaticUnitSimplex","text":"A unit simplex whose dimension is determined by its element type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.StaticUnitSphere","page":"Public API Reference","title":"DomainSets.StaticUnitSphere","text":"The unit sphere with fixed dimension(s) specified by the element type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.SublevelSet","page":"Public API Reference","title":"DomainSets.SublevelSet","text":"The domain defined by f(x) <= C (or f(x) < C) for a given function f and constant C.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.SubzeroSet","page":"Public API Reference","title":"DomainSets.SubzeroSet","text":"The domain where f(x) <= 0 (or f(x) < 0).\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.SuperlevelSet","page":"Public API Reference","title":"DomainSets.SuperlevelSet","text":"The domain defined by f(x) >= C (or f(x) > C) for a given function f and constant C.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.SuperzeroSet","page":"Public API Reference","title":"DomainSets.SuperzeroSet","text":"The domain where f(x) >= 0 (or f(x) > 0).\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.TupleProductDomain","page":"Public API Reference","title":"DomainSets.TupleProductDomain","text":"A TupleProductDomain is a product domain that concatenates the elements of its member domains in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.TypeDomain","page":"Public API Reference","title":"DomainSets.TypeDomain","text":"The domain of all objects of type T and all objects convertible exactly to type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnionDomain","page":"Public API Reference","title":"DomainSets.UnionDomain","text":"UnionDomain(domains...)\nUnionDomain{T}(domains...)\n\nThe lazy union of the given domains.\n\nSee also: uniondomain.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitBall","page":"Public API Reference","title":"DomainSets.UnitBall","text":"UnitBall([dim::Int])\nUnitBall{T}([dim::Int])\nUnitBall{T,C=:closed}([dim::Int])\n\nThe volume of all points of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitCircle","page":"Public API Reference","title":"DomainSets.UnitCircle","text":"The unit circle in 2D.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitCube","page":"Public API Reference","title":"DomainSets.UnitCube","text":"UnitCube()\nUnitCube(::Val{N=3})\nUnitCube(dim::Int)\n\nThe d-dimensional domain 01^d.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitInterval","page":"Public API Reference","title":"DomainSets.UnitInterval","text":"UnitInterval()\nUnitInterval{T=Float64}()\n\nThe closed unit interval [0,1].\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitSimplex","page":"Public API Reference","title":"DomainSets.UnitSimplex","text":"The unit simplex is a polytope with the origin and all unit vectors as vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitSphere","page":"Public API Reference","title":"DomainSets.UnitSphere","text":"The unit sphere.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.UnitSquare","page":"Public API Reference","title":"DomainSets.UnitSquare","text":"UnitSquare()\nUnitSquare{T=Float64}()\n\nThe domain 01^2.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.VcatDomain","page":"Public API Reference","title":"DomainSets.VcatDomain","text":"A VcatDomain concatenates the element types of its member domains in a single static vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.VectorDomain","page":"Public API Reference","title":"DomainSets.VectorDomain","text":"A VectorDomain is any domain whose eltype is Vector{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.VectorProductDomain","page":"Public API Reference","title":"DomainSets.VectorProductDomain","text":"A VectorProductDomain is a product domain of arbitrary dimension where the element type is a vector, and all member domains have the same element type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.VectorUnitBall","page":"Public API Reference","title":"DomainSets.VectorUnitBall","text":"The unit ball with vector elements of a given dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.VectorUnitCube","page":"Public API Reference","title":"DomainSets.VectorUnitCube","text":"The unit cube with vector elements of a given dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.VectorUnitSphere","page":"Public API Reference","title":"DomainSets.VectorUnitSphere","text":"The unit sphere with vector elements of a given dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DomainSets.ZeroSet","page":"Public API Reference","title":"DomainSets.ZeroSet","text":"The domain defined by f(x)=0 for a given function f.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#Euclidean-geometry","page":"Euclidean geometry","title":"Euclidean geometry","text":"","category":"section"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"Domains appearing in geometry are an important special case. A small number of primitive domains are implemented.","category":"page"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"DomainSets favours the definition of canonical types without state, which can be implemented as singleton types without fields. It is made easy to map the canonical domain to a more specific one, often using an affine map. See: Canonical domains, and in particular the functions mapfrom_canonical and mapto_canonical.","category":"page"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"For example, each ball, with any given radius and any center, can be obtained as the translation and scaling of a unit ball with radius one centered at the origin.","category":"page"},{"location":"geometry/#Intervals","page":"Euclidean geometry","title":"Intervals","text":"","category":"section"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"DomainSets uses IntervalSets.jl for the definition and manipulation of intervals. Most notably intervals can be easily created using the ellipsis notation a..b.","category":"page"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"IntervalSets supports open and closed intervals, finite and infinite intervals, and intervals of non-numeric types such as dates and times. See the documentation of the package for the full interface.","category":"page"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"A number of intervals with fixed endpoints, known at compile-time, are added in DomainSets, see Approximation intervals.","category":"page"},{"location":"geometry/#Rectangles-and-cubes","page":"Euclidean geometry","title":"Rectangles and cubes","text":"","category":"section"},{"location":"geometry/#Balls-and-spheres","page":"Euclidean geometry","title":"Balls and spheres","text":"","category":"section"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"The type hierarchy is as follows:","category":"page"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"abstract Ball\n|-> abstract UnitBall: radius is 1\n    |-> StaticUnitBall: dimension is part of type\n    |-> DynamicUnitBall: dimension is specified by int field\n|-> GenericBall: stores center and radius. Here, the dimension can be\n    obtained from the center, so there is only one type.","category":"page"},{"location":"geometry/","page":"Euclidean geometry","title":"Euclidean geometry","text":"Ball()\nSphere()","category":"page"},{"location":"geometry/#DomainSets.Ball-Tuple{}-geometry","page":"Euclidean geometry","title":"DomainSets.Ball","text":"Ball(radius = 1[, center])\nBall{T,C=:closed}(radius = 1[, center])\n\nReturn a concrete subtype of Ball which represents a ball with the given radius and center, the given eltype T, and which is open or closed.\n\nThe default center is the origin. In case both radius and center are omitted, a subtype of UnitBall is returned, whose concrete type depends on T.\n\nA ball represents a volume. For the boundary of a ball, see Sphere().\n\n\n\n\n\n","category":"method"},{"location":"geometry/#DomainSets.Sphere-Tuple{}-geometry","page":"Euclidean geometry","title":"DomainSets.Sphere","text":"Sphere(radius = 1[, center])\nSphere{T}(radius = 1[, center])\n\nReturn a concrete subtype of Sphere which represents a sphere with the given radius and center, and the given eltype T.\n\nThe default center is the origin. In case both radius and center are omitted, a subtype of UnitSphere is returned, whose concrete type depends on T.\n\nA sphere represents the boundary of a ball. For the volume, see Ball().\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Simplices","page":"Euclidean geometry","title":"Simplices","text":"","category":"section"},{"location":"internal/#Internal-API-Reference","page":"Internal API Reference","title":"Internal API Reference","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"This is an exhaustive list of all non-exported modules, constants, types, functions and macros in DomainSets.jl.","category":"page"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"warning: Warning\nUnexported functions and types are subject to change across different releases of the package, even if the release is said to be non-breaking. This overview is useful to better understand or to help develop the internals of DomainSets.","category":"page"},{"location":"internal/#Constants","page":"Internal API Reference","title":"Constants","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [DomainSets]\nOrder   = [:constant]\nPublic  = false\nPrivate = true","category":"page"},{"location":"internal/#Functions","page":"Internal API Reference","title":"Functions","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [DomainSets]\nOrder   = [:function]\nPublic  = false\nPrivate = true","category":"page"},{"location":"internal/#DomainSets.FunctionMaps.toexternalpoint-Union{Tuple{T}, Tuple{DomainSets.LazyDomain{T}, Any}} where T","page":"Internal API Reference","title":"DomainSets.FunctionMaps.toexternalpoint","text":"Inverse of tointernalpoint.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.FunctionMaps.tointernalpoint-Tuple{DomainSets.LazyDomain, Any}","page":"Internal API Reference","title":"DomainSets.FunctionMaps.tointernalpoint","text":"Translate a point of the lazy domain to a point (or points) of the composing domain.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.combine","page":"Internal API Reference","title":"DomainSets.combine","text":"Combine the outputs of in of member domains into a single output of the lazy domain.\n\n\n\n\n\n","category":"function"},{"location":"internal/#DomainSets.domain_tolerance-Tuple{Any}","page":"Internal API Reference","title":"DomainSets.domain_tolerance","text":"Return a suitable tolerance to use for verifying whether a point is close to a domain. Typically, the tolerance is close to the precision limit of the numeric type associated with the domain.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.indicatorfunction-Tuple{Any}","page":"Internal API Reference","title":"DomainSets.indicatorfunction","text":"The indicator function of a domain is the function f(x) = x ∈ D.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.intersectbox-Tuple{Any}","page":"Internal API Reference","title":"DomainSets.intersectbox","text":"Return the bounding box of the intersection of two or more bounding boxes.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.iscompatiblepair-Tuple{Any, Any}","page":"Internal API Reference","title":"DomainSets.iscompatiblepair","text":"Is the given combination of point and domain compatible?\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.parametric_domain-Tuple{Any, Any}","page":"Internal API Reference","title":"DomainSets.parametric_domain","text":"Return the domain that results from mapping the given domain.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.promotable_domains-Tuple","page":"Internal API Reference","title":"DomainSets.promotable_domains","text":"Can the domains be promoted without throwing an error?\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.promote_domains-Tuple{}","page":"Internal API Reference","title":"DomainSets.promote_domains","text":"Promote the given domains to have a common element type.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.promote_pair-Tuple{Any, Any}","page":"Internal API Reference","title":"DomainSets.promote_pair","text":"Promote point and domain to compatible types.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.similar_interval-Union{Tuple{T}, Tuple{S}, Tuple{DomainSets.FixedInterval{:closed, :closed, T}, S, S}} where {S, T}","page":"Internal API Reference","title":"DomainSets.similar_interval","text":"Return an interval that is similar to the given interval, but with endpoints a and b instead.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.simplifies-Tuple{Any}","page":"Internal API Reference","title":"DomainSets.simplifies","text":"Does the domain simplify?\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.simplify-Tuple{Any}","page":"Internal API Reference","title":"DomainSets.simplify","text":"Simplify the given domain to an equal domain.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.todomainset-Tuple{Domain}","page":"Internal API Reference","title":"DomainSets.todomainset","text":"Convert the given domain to a domain defined in DomainSets.jl.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.unionbox-Tuple{Any}","page":"Internal API Reference","title":"DomainSets.unionbox","text":"Return the bounding box of the union of two or more bounding boxes.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.vectorized_approx_in-Tuple{Any, Any}","page":"Internal API Reference","title":"DomainSets.vectorized_approx_in","text":"Vectorized version of approx_in: apply x ∈ d to all elements of A.\n\n\n\n\n\n","category":"method"},{"location":"internal/#DomainSets.vectorized_in-Tuple{Any, Any}","page":"Internal API Reference","title":"DomainSets.vectorized_in","text":"Vectorized version of in: apply x ∈ d to all elements of A.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Types","page":"Internal API Reference","title":"Types","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [DomainSets]\nOrder   = [:type]\nPublic  = false\nPrivate = true","category":"page"},{"location":"internal/#DomainSets.AbstractIndicatorFunction","page":"Internal API Reference","title":"DomainSets.AbstractIndicatorFunction","text":"Supertype of domains that are defined by an indicator function.\n\nAn indicator function is a function f : S -> [0,1] that indicates membership of x to a domain D with D ⊂ S. The indicator function corresponds exactly to the in function of a domain: f(x) = x ∈ D.\n\nConcrete subtypes of AbstractIndicatorFunction store a representation of this indicator function and implement in using that representation, rather than implementing in directly.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.AbstractLevelSet","page":"Internal API Reference","title":"DomainSets.AbstractLevelSet","text":"Supertype of level set domains of the form f(x)=C.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.AbstractMappedDomain","page":"Internal API Reference","title":"DomainSets.AbstractMappedDomain","text":"A MappedDomain represents the mapping of a domain.\n\nThe map of a domain d under the mapping y=f(x) consists of all points f(x) with x ∈ d. The characteristic function of a mapped domain is defined in terms of the inverse map g = inverse(f):\n\nx ∈ m ⟺ g(x) ∈ d\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.AbstractSublevelSet","page":"Internal API Reference","title":"DomainSets.AbstractSublevelSet","text":"Supertype of sublevel set domains.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.AbstractSuperlevelSet","page":"Internal API Reference","title":"DomainSets.AbstractSuperlevelSet","text":"Supertype of superlevel set domains.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.AbstractVectorDomain","page":"Internal API Reference","title":"DomainSets.AbstractVectorDomain","text":"An AbstractVectorDomain is any domain whose eltype is <:AbstractVector{T}.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.BoundedIndicatorFunction","page":"Internal API Reference","title":"DomainSets.BoundedIndicatorFunction","text":"An indicator function with a known bounding domain.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.CompositeDomain","page":"Internal API Reference","title":"DomainSets.CompositeDomain","text":"A composite lazy domain is defined in terms of multiple domains.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.Cube","page":"Internal API Reference","title":"DomainSets.Cube","text":"A Cube is a hyperrectangle with equal side lengths in each dimension.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.DerivedDomain","page":"Internal API Reference","title":"DomainSets.DerivedDomain","text":"Abstract supertype for domains that wrap another domain.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.DomainPoint","page":"Internal API Reference","title":"DomainSets.DomainPoint","text":"A DomainPoint is a point which is an element of a domain by construction.\n\nA domain point is just a point, not a domain. This is different from a Point type.\n\nThe type is a wrapper: retrieve the underlying point using point(p).\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.DomainSetStyle","page":"Internal API Reference","title":"DomainSets.DomainSetStyle","text":"The broadcast style associated with domains\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.EuclideanBall","page":"Internal API Reference","title":"DomainSets.EuclideanBall","text":"A ball in a fixed N-dimensional Euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.EuclideanCube","page":"Internal API Reference","title":"DomainSets.EuclideanCube","text":"A cube in a fixed N-dimensional Euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.EuclideanSphere","page":"Internal API Reference","title":"DomainSets.EuclideanSphere","text":"A hypersphere in a fixed N-dimensional Euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.EuclideanSpherePoint","page":"Internal API Reference","title":"DomainSets.EuclideanSpherePoint","text":"A point on the unit sphere represented by a standard Euclidean vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.ExampleNamedDomain","page":"Internal API Reference","title":"DomainSets.ExampleNamedDomain","text":"Example of a domain that wraps another domain and thus obtains its own type.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.FixedInterval","page":"Internal API Reference","title":"DomainSets.FixedInterval","text":"The abstract type FixedInterval is the supertype of intervals with endpoints determined by the type, rather than field values. Examples include UnitInterval and ChebyshevInterval.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.FixedIntervalProduct","page":"Internal API Reference","title":"DomainSets.FixedIntervalProduct","text":"The N-fold cartesian product of a fixed interval.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.FunctionLevelSet","page":"Internal API Reference","title":"DomainSets.FunctionLevelSet","text":"A FunctionLevelSet is a set that derives from the levels of a function.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.GenericBall","page":"Internal API Reference","title":"DomainSets.GenericBall","text":"A GenericBall is a ball with a given radius and center.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.GenericSphere","page":"Internal API Reference","title":"DomainSets.GenericSphere","text":"A GenericSphere is a sphere with a given radius and center.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.HyperRectangle","page":"Internal API Reference","title":"DomainSets.HyperRectangle","text":"A HyperRectangle is the cartesian product of intervals.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.Isomorphic","page":"Internal API Reference","title":"DomainSets.Isomorphic","text":"A canonical domain that is isomorphic but may have different element type.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.LazyComposedMap","page":"Internal API Reference","title":"DomainSets.LazyComposedMap","text":"Supertype of all compositions of a lazy domain. The composition determines how the point x is distributed to the member domains of a lazy domain.\n\nThree compositions implemented in the package are:\n\nNoComposedMap: the lazy domain encapsulates a single domain and x is passed\n\nthrough unaltered\n\nCombination: the lazy domain has several members and x is passed to the in\n\nmethod of all members\n\nProduct: the lazy domain has several members and the components of x are\n\npassed to the components of the lazy domain\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.LazyDomain","page":"Internal API Reference","title":"DomainSets.LazyDomain","text":"A lazy domain evaluates its membership function on the fly in terms of that of other domains.\n\nThe in(x, domain::LazyDomain) applies three types of transformations:\n\nPoint mapping: y = tointernalpoint(domain, x)\nDistribution of y over member domains given by components(domain)\nCombination of the outputs into a single boolean result.\n\nThe distribution step is determined by the result of composition(domain), see composition. The combination is performed by combine. Mapping between points of the lazy domain and points of its member domains is described by y = tointernalpoint(domain, x) and x = toexternalpoint(domain, y).\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.NaturalNumbers","page":"Internal API Reference","title":"DomainSets.NaturalNumbers","text":"The set of all natural numbers.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.NegativeRealLine","page":"Internal API Reference","title":"DomainSets.NegativeRealLine","text":"NegativeRealLine{T=Float64}()\n\nThe open negative halfline (-∞,0).\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.NonnegativeRealLine","page":"Internal API Reference","title":"DomainSets.NonnegativeRealLine","text":"NonnegativeRealLine{T=Float64}()\n\nThe closed positive halfline [0,∞).\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.NonpositiveRealLine","page":"Internal API Reference","title":"DomainSets.NonpositiveRealLine","text":"NonpositiveRealLine{T=Float64}()\n\nThe closed negative halfline (-∞,0].\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.Parameterization","page":"Internal API Reference","title":"DomainSets.Parameterization","text":"A parameter domain that can be mapped to the domain.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.ParametricDomain","page":"Internal API Reference","title":"DomainSets.ParametricDomain","text":"A ParametricDomain stores the forward map of a mapped domain.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.PositiveRealLine","page":"Internal API Reference","title":"DomainSets.PositiveRealLine","text":"PositiveRealLine{T=Float64}()\n\nThe open positive halfline (0,∞).\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.SimpleLazyDomain","page":"Internal API Reference","title":"DomainSets.SimpleLazyDomain","text":"A simple lazy domain is defined in terms of a single domain.\n\nIt has no composition and no combination of its in function.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.Simplex","page":"Internal API Reference","title":"DomainSets.Simplex","text":"Supertype of an N-dimensional simplex.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.SpherePoint","page":"Internal API Reference","title":"DomainSets.SpherePoint","text":"A point on the unit sphere.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.SphericalCoordinate","page":"Internal API Reference","title":"DomainSets.SphericalCoordinate","text":"A point on the unit sphere represented in spherical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.VectorBall","page":"Internal API Reference","title":"DomainSets.VectorBall","text":"A ball with vector elements of variable length.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.VectorCube","page":"Internal API Reference","title":"DomainSets.VectorCube","text":"A cube with vector elements of variable length.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.VectorSphere","page":"Internal API Reference","title":"DomainSets.VectorSphere","text":"A sphere with vector elements of variable length.\n\n\n\n\n\n","category":"type"},{"location":"internal/#DomainSets.WrappedDomain","page":"Internal API Reference","title":"DomainSets.WrappedDomain","text":"A WrappedDomain is a wrapper around an object that implements the domain interface, and that is itself a domain.\n\n\n\n\n\n","category":"type"},{"location":"equality/#Equality-of-domains","page":"Equality of domains","title":"Equality of domains","text":"","category":"section"},{"location":"equality/","page":"Equality of domains","title":"Equality of domains","text":"A domain behaves as much as possible like the mathematical set it represents, irrespective of its type. Thus, for example, two domains are considered equal if their membership functions agree.","category":"page"},{"location":"equality/","page":"Equality of domains","title":"Equality of domains","text":"It is not always possible to realize this intended behaviour in practice. Indeed it may be difficult to discover automatically whether two domains are equal, especially when their types are different. Deciding whether two domains are equal requires supporting implementation, hence the outcome is not always accurate. Still, the principle serves as a design goal.","category":"page"},{"location":"equality/","page":"Equality of domains","title":"Equality of domains","text":"julia> UnitInterval() == UnitSimplex{Float64}() == 0..1\ntrue\n\njulia> ChebyshevInterval() == UnitBall{Float64}() == -1 .. 1\ntrue","category":"page"},{"location":"equality/","page":"Equality of domains","title":"Equality of domains","text":"Equality of domains is decided by the isequaldomain function in general, and simply by == for subtypes of the Domain supertype.","category":"page"},{"location":"equality/","page":"Equality of domains","title":"Equality of domains","text":"isequaldomain","category":"page"},{"location":"equality/#DomainSets.isequaldomain-equality","page":"Equality of domains","title":"DomainSets.isequaldomain","text":"isequaldomain(d1, d2)\n\nAre the two given domains equal?\n\nDomains are considered equal if their membership functions return the same output for the same input.\n\nIt is not always possible to verify this automatically. If the result is true, then the domains are guaranteed to be equal. If the result is false, then either the domains are not equal or they are equal but the implementation fails to recognize this.\n\n\n\n\n\n","category":"function"},{"location":"equality/","page":"Equality of domains","title":"Equality of domains","text":"note: Note\nIf two domains are equal according to ==, then their hashes are also equal. This allows the use of domains as keys in a Dict, if one is so inclined.","category":"page"},{"location":"maps/#FunctionMaps.jl","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"","category":"section"},{"location":"maps/#What-is-FunctionMaps.jl","page":"FunctionMaps.jl","title":"What is FunctionMaps.jl","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"FunctionMaps is a submodule of DomainSets as of version 0.7.10. The module collects all functionality in the package that relates to functions in the sense of a map between spaces. It defines properties such as the jacobian etcetera.","category":"page"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"The module is expected to be moved into a separate package in the future and will be independently documented.","category":"page"},{"location":"maps/#Public-API-Reference","page":"FunctionMaps.jl","title":"Public API Reference","text":"","category":"section"},{"location":"maps/#Constants","page":"FunctionMaps.jl","title":"Constants","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"Modules = [FunctionMaps]\nOrder   = [:constant]\nPublic  = true\nPrivate = false","category":"page"},{"location":"maps/#Functions","page":"FunctionMaps.jl","title":"Functions","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"Modules = [FunctionMaps]\nOrder   = [:function]\nPublic  = true\nPrivate = false","category":"page"},{"location":"maps/#DomainSets.FunctionMaps.affinematrix-Tuple{DomainSets.FunctionMaps.AbstractAffineMap}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.affinematrix","text":"Return the matrix A in the affine map Ax+b.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.affinevector-Tuple{DomainSets.FunctionMaps.AbstractAffineMap}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.affinevector","text":"Return the vector b in the affine map Ax+b.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.canonicalmap-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.canonicalmap","text":"canonicalmap([ctype::CanonicalType, ]map)\n\nReturn an associated canonical map, if any, of the given map.\n\nOptionally, a canonical type argument may specify an alternative canonical map. Canonical maps help with converting between equal maps of different types.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.codomaintype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.codomaintype","text":"codomaintype(m[, T])\n\nWhat is the codomain type of the function map m, given that T is its domain type?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.convert_numtype-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.convert_numtype","text":"convert_numtype(T, x)\n\nConvert x such that its numtype equals T.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.convert_prectype-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.convert_prectype","text":"convert_prectype(T, x)\n\nConvert x such that its prectype equals T.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.diffvolume-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.diffvolume","text":"diffvolume(m[, x])\n\nCompute the differential volume (at a point x). If J is the Jacobian matrix, possibly rectangular, then the differential volume is sqrt(det(J'*J)).\n\nIf the map is square, then the differential volume is the absolute value of the Jacobian determinant.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.domaintype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.domaintype","text":"What is the expected type of a point in the domain of the function map m?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.inverse-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.inverse","text":"inverse(m[, x])\n\nReturn the inverse of m. The two-argument function evaluates the inverse at the point x.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.isequalmap-Tuple{Any, Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.isequalmap","text":"Are the two given maps equal?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.jacdet-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.jacdet","text":"jacdet(m[, x])\n\nReturn the determinant of the jacobian as a map. The two-argument version evaluates the jacobian determinant at a point x.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.jacobian-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.jacobian","text":"jacobian(m::AbstractMap[, x])\n\nReturn the jacobian map. The two-argument version evaluates the jacobian at a point x.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.leftinverse-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.leftinverse","text":"leftinverse(m[, x])\n\nReturn a left inverse of the given map. This left inverse mli is not unique, but in any case it is such that (mli ∘ m) * x = x for each x in the domain of m.\n\nThe two-argument function applies the left inverse to the point x.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.numtype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.numtype","text":"The numeric element type of x in a Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.prectype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.prectype","text":"prectype(x[, ...])\n\nThe floating point precision type associated with the argument(s).\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.rightinverse-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.rightinverse","text":"rightinverse(m[, x])\n\nReturn a right inverse of the given map. This right inverse mri is not unique, but in any case it is such that (m ∘ mri) * y = y for each y in the range of m.\n\nThe two-argument function applies the right inverse to the point x.\n\n\n\n\n\n","category":"method"},{"location":"maps/#Types","page":"FunctionMaps.jl","title":"Types","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"Modules = [FunctionMaps]\nOrder   = [:type]\nPublic  = true\nPrivate = false","category":"page"},{"location":"maps/#DomainSets.FunctionMaps.AffineMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.AffineMap","text":"The supertype of all affine maps that store A and b. Concrete subtypes differ in how A and b are represented.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ConstantMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ConstantMap","text":"The supertype of constant maps from T to U.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.IdentityMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.IdentityMap","text":"Supertype of identity maps.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.LinearMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.LinearMap","text":"The supertype of all linear maps y = A*x. Concrete subtypes may differ in how A is represented.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.Map","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.Map","text":"A Map{T} is a map of a single variable of type T.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.MapRef","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.MapRef","text":"MapRef(m)\n\nA reference to a map.\n\nIn a function call, MapRef(x) can be used to indicate that x should be treated as a map, e.g., foo(x, MapRef(m)).\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.StaticIdentityMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.StaticIdentityMap","text":"The identity map for variables of type T.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.Translation","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.Translation","text":"A Translation represents the map y = x + b.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.UnityMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.UnityMap","text":"The unity map f(x) = 1.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ZeroMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ZeroMap","text":"The zero map f(x) = 0.\n\n\n\n\n\n","category":"type"},{"location":"maps/#Internal-API-Reference","page":"FunctionMaps.jl","title":"Internal API Reference","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"This is an exhaustive list of all non-exported constants, types and functions in FunctionMaps.jl.","category":"page"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"warning: Warning\nUnexported functions and types are subject to change across different releases of the package, even if the release is said to be non-breaking.","category":"page"},{"location":"maps/#Constants-2","page":"FunctionMaps.jl","title":"Constants","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"Modules = [FunctionMaps]\nOrder   = [:constant]\nPublic  = false\nPrivate = true","category":"page"},{"location":"maps/#DomainSets.FunctionMaps.AnyMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.AnyMap","text":"AnyMap is the union of Map and MapRef.\n\nIn both cases map(m::AnyMap) returns the map itself.\n\n\n\n\n\n","category":"type"},{"location":"maps/#Functions-2","page":"FunctionMaps.jl","title":"Functions","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"Modules = [FunctionMaps]\nOrder   = [:function]\nPublic  = false\nPrivate = true","category":"page"},{"location":"maps/#DomainSets.FunctionMaps.affine_composition-Tuple{DomainSets.FunctionMaps.AbstractAffineMap, DomainSets.FunctionMaps.AbstractAffineMap}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.affine_composition","text":"Compute the affine map that represents map2 after map1, that is: y = a2*(a1*x+b1)+b2 = a2*a1*x + a2*b1 + b2.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.bounded_interval_map-NTuple{4, Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.bounded_interval_map","text":"Like interval_map, but guaranteed to return a scalar affine map.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.canonicalextensiontype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.canonicalextensiontype","text":"Return the extension type associated with the given object.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.checkmap-Tuple{Map}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.checkmap","text":"checkmap(m)\n\nChecks that m is a map or refers to a map and if so returns that map, throws an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.convert_eltype-Union{Tuple{T}, Tuple{Type{T}, AbstractArray}} where T","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.convert_eltype","text":"convert_eltype(T, x)\n\nConvert x such that its eltype equals T.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.convert_fromcartesian-Union{Tuple{DIM}, Tuple{AbstractVector{T} where T, Val{DIM}}} where DIM","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.convert_fromcartesian","text":"Convert a vector from a cartesian format to a nested tuple according to the given dimensions.\n\nFor example: convert_fromcartesian([1,2,3,4,5], Val{(2,2,1)}()) -> ([1,2],[3,4],5)\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.convert_tocartesian-Union{Tuple{DIM}, Tuple{Any, Val{DIM}}} where DIM","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.convert_tocartesian","text":"The inverse function of convert_fromcartesian.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.euclideandimension-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.euclideandimension","text":"What is the euclidean dimension of the given type (if applicable)?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.factor-Tuple{Any, Vararg{Any, N} where N}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.factor","text":"Factor I... of a product-like composite object.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.factors","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.factors","text":"Factors of a product-like composite object (equivalent to components(d)).\n\n\n\n\n\n","category":"function"},{"location":"maps/#DomainSets.FunctionMaps.functionmap-Tuple{Map}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.functionmap","text":"functionmap(m)\n\nReturn a map associated with the object m.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.glm_domaintype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.glm_domaintype","text":"What is the suggested domaintype for a generic linear map A*x with the given argument 'A'?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.hascanonicalmap-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.hascanonicalmap","text":"Does the map have a canonical map?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.hashrec-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.hashrec","text":"Apply the hash function recursively to the given arguments.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.identitymatrix-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.identitymatrix","text":"Return an identity matrix with the same size as the map.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.interval_map-NTuple{4, Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.interval_map","text":"Map the interval [a,b] to the interval [c,d].\n\nThis function deals with infinite intervals, and the type of the map returned may depend on the value (finiteness) of the given endpoints.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.issquaremap-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.issquaremap","text":"Is the given map a square map?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.isvectorvalued-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.isvectorvalued","text":"Is the map a vector-valued function, i.e., a function from Rn to Rm?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.nfactors-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.nfactors","text":"The number of factors of a product-like composite object.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.promotable_eltypes-Tuple","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.promotable_eltypes","text":"Are the given element types promotable to a concrete supertype?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.promotable_maps-Tuple","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.promotable_maps","text":"Can the maps be promoted to a common domain type without throwing an error?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.promote_map_point_pair-Tuple{Any, Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.promote_map_point_pair","text":"Promote map and point to compatible types.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.promote_maps-Tuple{}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.promote_maps","text":"Promote the given maps to have a common domain type.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.promote_numtype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.promote_numtype","text":"promote_numtype(a, b[, ...])\n\nPromote the numeric types of the arguments to a joined supertype.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.promote_prectype-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.promote_prectype","text":"promote_prectype(a, b[, ...])\n\nPromote the precision types of the arguments to a joined supertype.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.simplifies-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.simplifies","text":"Does the map simplify?\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.simplify-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.simplify","text":"Simplify the given map to an equal map.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.to_matrix-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.to_matrix","text":"to_matrix(::Type{T}, A[, b])\n\nConvert the A in the affine map A*x or A*x+b with domaintype T to a matrix.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.to_numtype-Union{Tuple{U}, Tuple{T}, Tuple{Type{U}, Type{T}}} where {T, U}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.to_numtype","text":"to_numtype(U, T)\n\nReturn the type to which T can be converted, such that the numtype becomes U.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.to_prectype-Union{Tuple{U}, Tuple{T}, Tuple{Type{U}, Type{T}}} where {T, U}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.to_prectype","text":"to_prectype(U, T)\n\nReturn the type to which T can be converted, such that the prectype becomes U.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.to_vector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.to_vector","text":"to_vector(::Type{T}, A[, b])\n\nConvert the b in the affine map A*x or A*x+b with domaintype T to a vector.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.tofunctionmap-Tuple{Map}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.tofunctionmap","text":"Convert the given map to a map defined in FunctionMaps.jl.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.zeromatrix-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.zeromatrix","text":"Return a zero matrix of the same size as the map.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.zerovector-Tuple{Any}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.zerovector","text":"Return a zero vector of the same size as the codomain of the map.\n\n\n\n\n\n","category":"method"},{"location":"maps/#Types-2","page":"FunctionMaps.jl","title":"Types","text":"","category":"section"},{"location":"maps/","page":"FunctionMaps.jl","title":"FunctionMaps.jl","text":"Modules = [FunctionMaps]\nOrder   = [:type]\nPublic  = false\nPrivate = true","category":"page"},{"location":"maps/#DomainSets.FunctionMaps.AbsMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.AbsMap","text":"An AbsMap returns the absolute value of the result of a given map.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.AbstractAffineMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.AbstractAffineMap","text":"An affine map has the general form y = A*x + b.\n\nWe use affinematrix(m) and affinevector(m) to denote A and b respectively. Concrete subtypes include linear maps of the form y = A*x and translations of the form y = x + b.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.AbstractMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.AbstractMap","text":"An AbstractMap represents a function y=f(x) of a single variable.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.AngleMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.AngleMap","text":"AngleMap is a left inverse of UnitCircleMap. A 2D vector x is projected onto the intersection point with the unit circle of the line connecting x to the origin. The angle of this point, scaled to the interval [0,1), is the result.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.CanonicalExtensionType","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.CanonicalExtensionType","text":"Canonical types used to translate between packages.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.CanonicalType","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.CanonicalType","text":"Supertype of different kinds of canonical objects.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.CartToPolarMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.CartToPolarMap","text":"A Cartesion to Polar map. First dimension is interpreted as radial distance, second as an angle. The unit circle is mapped to the square [-1,1]x[-1,1].\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ComplexToVector-Tuple{}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ComplexToVector","text":"ComplexToVector()\nComplexToVector{T}()\n\nMap a complex number z=a+bi to the length 2 vector a b.\n\nSee also: FunctionMaps.VectorToComplex.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.ComposedMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ComposedMap","text":"The composition of several maps.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.CompositeLazyMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.CompositeLazyMap","text":"A composite lazy map is defined in terms of several other maps.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.DerivedMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.DerivedMap","text":"A DerivedMap inherits all of its properties from another map, but has its own type.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.DeterminantMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.DeterminantMap","text":"A DeterminantMap returns the determinant of the result of a given map.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.DynamicIdentityMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.DynamicIdentityMap","text":"Identity map with dynamic size determined by a dimension field.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.Equal","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.Equal","text":"A canonical object that is equal but simpler.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.Equivalent","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.Equivalent","text":"A canonical object that is equivalent but may have different type.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.FixedConstantMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.FixedConstantMap","text":"The constant map f(x) = c.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.FlatToNested","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.FlatToNested","text":"Map a flattened vector to a nested one.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.GenericAffineMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.GenericAffineMap","text":"An affine map for any combination of types of A and b.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.GenericLinearMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.GenericLinearMap","text":"A GenericLinearMap is a linear map y = A*x for any type of A.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.GenericTranslation","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.GenericTranslation","text":"Translation by a generic vectorlike object.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.IsMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.IsMap","text":"IsMap()\n\nindicates an object implements the map interface.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.Isomorphism","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.Isomorphism","text":"Isomorphism{T,U} <: TypedMap{T,U}\n\nAn isomorphism is a bijection between types that preserves norms.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.LazyDiffVolume","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.LazyDiffVolume","text":"A lazy volume element evaluates to diffvolume(m, x) on the fly.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.LazyInverse","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.LazyInverse","text":"A lazy inverse stores a map m and returns inverse(m, x).\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.LazyJacobian","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.LazyJacobian","text":"A lazy Jacobian J stores a map m and returns J(x) = jacobian(m, x).\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.LazyMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.LazyMap","text":"A lazy map has an action that is defined in terms of other maps. Those maps are stored internally, and the action of the lazy map is computed on-the-fly and only when invoked.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.MapStyle","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.MapStyle","text":"MapStyle(m)\n\nTrait to indicate whether or not m implements the map interface.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.MulMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.MulMap","text":"The lazy multiplication of one or more maps.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.NestedToFlat","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.NestedToFlat","text":"Map a nested vector or tuple to a flat vector.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.NotMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.NotMap","text":"NotMap()\n\nindicates an object does not implement the Map interface.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.NumberToVector-Tuple{}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.NumberToVector","text":"NumberToVector()\nNumberToVector{T}()\n\nMap a number x to the length 1 vector [x].\n\nSee also: VectorToNumber.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.PolarToCartMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.PolarToCartMap","text":"A Polar to Cartesian map. The angle is mapped to the second dimension, radius to the first. The square [-1,1]x[-1,1] is mapped to the unit circle.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ProductMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ProductMap","text":"A product map is diagonal and acts on each of the components of x separately: y = f(x) becomes y_i = f_i(x_i).\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ScalarAffineMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ScalarAffineMap","text":"An affine map with scalar representation.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ScalarLinearMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ScalarLinearMap","text":"A ScalarLinearMap is a linear map y = A*x for scalars.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.ScalarTranslation","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.ScalarTranslation","text":"Translation by a scalar value.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.SimpleLazyMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.SimpleLazyMap","text":"A simple lazy map derives from a single other map.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.StaticAffineMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.StaticAffineMap","text":"An affine map with representation using static arrays.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.StaticLinearMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.StaticLinearMap","text":"A StaticLinearMap is a linear map y = A*x using static arrays.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.StaticTranslation","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.StaticTranslation","text":"Translation by a static vector.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.SumMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.SumMap","text":"The lazy sum of one or more maps.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.TupleProductMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.TupleProductMap","text":"A TupleProductMap is a product map with all components collected in a tuple. There is no vector-valued function associated with this map.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.TupleToVector","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.TupleToVector","text":"Map a tuple to a static vector.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.TypedMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.TypedMap","text":"A TypedMap{T,U} maps a variable of type T to a variable of type U.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.UnitCircleMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.UnitCircleMap","text":"The map [cos(2πt), sin(2πt)] from [0,1] to the unit circle in ℝ^2.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.UnitDiskMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.UnitDiskMap","text":"The map r*[cos(2πt), sin(2πt)] from [0,1]^2 to the unit disk in ℝ^2.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.VcatMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VcatMap","text":"A VcatMap is a product map with domain and codomain vectors concatenated (vcat) into a single vector.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.VectorAffineMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorAffineMap","text":"An affine map with array and vector representation.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.VectorLinearMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorLinearMap","text":"A VectorLinearMap is a linear map y = A*x using vectors and matrices.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.VectorProductMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorProductMap","text":"A VectorProductMap is a product map where all components are univariate maps, with inputs and outputs collected into a Vector.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.VectorToComplex-Tuple{}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorToComplex","text":"VectorToComplex()\nVectorToComplex{T}()\n\nThe map ab  a+bi from ℝ^2 to ℂ.\n\nSee also: FunctionMaps.ComplexToVector.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.VectorToNumber-Tuple{}","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorToNumber","text":"VectorToNumber()\nVectorToNumber{T}()\n\nMap a length 1 vector x to the number x[1].\n\nSee also: NumberToVector.\n\n\n\n\n\n","category":"method"},{"location":"maps/#DomainSets.FunctionMaps.VectorToTuple","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorToTuple","text":"Map a static vector to a tuple.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.VectorTranslation","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.VectorTranslation","text":"Translation by a vector.\n\n\n\n\n\n","category":"type"},{"location":"maps/#DomainSets.FunctionMaps.WrappedMap","page":"FunctionMaps.jl","title":"DomainSets.FunctionMaps.WrappedMap","text":"A WrappedMap{T} takes any object and turns it into a Map{T}.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#Approximation-domains","page":"Function approximation","title":"Approximation domains","text":"","category":"section"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"DomainSets has its roots in the JuliaApproximation community. It is used for example in the packages ApproxFun and BasisFunctions.","category":"page"},{"location":"approximation/#Approximation-intervals","page":"Function approximation","title":"Approximation intervals","text":"","category":"section"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"There are a number of stateless intervals (i.e. singleton types without data) to represent standard intervals used in approximation theory. The endpoints of these intervals are fixed and hence, at least in principle, known to the compiler.","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"UnitInterval\nChebyshevInterval\nHalfLine\nNegativeHalfLine","category":"page"},{"location":"approximation/#DomainSets.UnitInterval-approximation","page":"Function approximation","title":"DomainSets.UnitInterval","text":"UnitInterval()\nUnitInterval{T=Float64}()\n\nThe closed unit interval [0,1].\n\n\n\n\n\n","category":"type"},{"location":"approximation/#DomainSets.ChebyshevInterval-approximation","page":"Function approximation","title":"DomainSets.ChebyshevInterval","text":"ChebyshevInterval()\nChebyshevInterval{T=Float64}()\n\nThe closed interval [-1,1].\n\n\n\n\n\n","category":"type"},{"location":"approximation/#DomainSets.HalfLine-approximation","page":"Function approximation","title":"DomainSets.HalfLine","text":"HalfLine()\nHalfLine{T=Float64,C=:closed}()\n\nThe positive halfline [0,∞) when C is :closed or (0,∞) when C is :open. The interval is always open at infinity.\n\nSee also: NonnegativeRealLine, PositiveRealLine.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#DomainSets.NegativeHalfLine-approximation","page":"Function approximation","title":"DomainSets.NegativeHalfLine","text":"NegativeHalfLine()\nNegativeHalfLine{T=Float64,C=:closed}()\n\nThe negative halfline (-∞,0] when C is :closed or (-∞,0) when C is :open. The interval is always open at minus infinity.\n\nSee also: NonpositiveRealLine, NegativeRealLine.\n\n\n\n\n\n","category":"type"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"The types are simple enough that some common set arithmetic operations retain their special structure:","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"julia> HalfLine() ∩ ChebyshevInterval()\n0.0 .. 1.0 (Unit)\n\njulia> NegativeHalfLine() \\ UnitInterval()\n-Inf .. 0.0 (open) (NegativeHalfLine)","category":"page"},{"location":"approximation/#The-unit-cube-and-other-cubes","page":"Function approximation","title":"The unit cube and other cubes","text":"","category":"section"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"The product domain associated with any of the fixed intervals remains stateless if the dimension is fixed as well:","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"julia> UnitInterval()^2\nUnitSquare()\n\njulia> ChebyshevInterval()^3\n(-1.0 .. 1.0 (Chebyshev)) × (-1.0 .. 1.0 (Chebyshev)) × (-1.0 .. 1.0 (Chebyshev))","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"Some special cases are named.","category":"page"},{"location":"approximation/","page":"Function approximation","title":"Function approximation","text":"UnitSquare\nUnitCube","category":"page"},{"location":"approximation/#DomainSets.UnitSquare-approximation","page":"Function approximation","title":"DomainSets.UnitSquare","text":"UnitSquare()\nUnitSquare{T=Float64}()\n\nThe domain 01^2.\n\n\n\n\n\n","category":"type"},{"location":"approximation/#DomainSets.UnitCube-approximation","page":"Function approximation","title":"DomainSets.UnitCube","text":"UnitCube()\nUnitCube(::Val{N=3})\nUnitCube(dim::Int)\n\nThe d-dimensional domain 01^d.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These are the same examples as those in the README of the package repository.","category":"page"},{"location":"examples/#Intervals","page":"Examples","title":"Intervals","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"DomainSets.jl uses IntervalSets.jl for closed and open intervals. In addition, it defines a few standard intervals.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using DomainSets\n\njulia> UnitInterval()\n0.0..1.0 (Unit)\n\njulia> ChebyshevInterval()\n-1.0..1.0 (Chebyshev)\n\njulia> HalfLine()\n0.0..Inf (closed–open) (HalfLine)","category":"page"},{"location":"examples/#Rectangles","page":"Examples","title":"Rectangles","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Rectangles can be constructed as a product of intervals, where the elements of the domain are SVector{2}:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using DomainSets: ×\n\njulia> (-1..1) × (0..3) × (4.0..5.0)\n(-1.0..1.0) × (0.0..3.0) × (4.0..5.0)\n\njulia> [1,2] in (-1..1) × (0..3)\ntrue\n\njulia> UnitInterval()^3\nUnitCube()","category":"page"},{"location":"examples/#Circles-and-Spheres","page":"Examples","title":"Circles and Spheres","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A UnitSphere  contains x if norm(x) == 1. The unit sphere is N-dimensional, and its dimension is specified with the constructor. The element types are SVector{N,T} when the dimension is specified as Val(3), and they are Vector{T} when the dimension is specified by an integer value instead:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using StaticArrays\n\njulia> SA[0,0,1.0] in UnitSphere(Val(3))\ntrue\n\njulia> [0.0,1.0,0.0,0.0] in UnitSphere(4)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"UnitSphere itself is an abstract type, hence the examples above return concrete types <:UnitSphere. The intended element type can also be explicitly specified with the UnitSphere{T} constructor:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> typeof(UnitSphere{SVector{3,BigFloat}}())\nEuclideanUnitSphere{3, BigFloat} (alias for StaticUnitSphere{SArray{Tuple{3}, BigFloat, 1, 3}})\n\njulia> typeof(UnitSphere{Vector{Float32}}(6))\nVectorUnitSphere{Float32} (alias for DynamicUnitSphere{Array{Float32, 1}})","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Without arguments, UnitSphere() defaults to a 3D domain with SVector{3,Float64} elements. Similarly, there is a special case UnitCircle in 2D:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SVector(1,0) in UnitCircle()\ntrue","category":"page"},{"location":"examples/#Disks-and-Balls","page":"Examples","title":"Disks and Balls","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A UnitBall  contains x if norm(x) ≤ 1. As with UnitSphere, the dimension is specified via the constructor by type or by value:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SVector(0.1,0.2,0.3) in UnitBall(Val(3))\ntrue\n\njulia> [0.1,0.2,0.3,-0.1] in UnitBall(4)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By default N=3, but UnitDisk is a special case in 2D, and so are ComplexUnitDisk and ComplexUnitCircle in the complex plane:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SVector(0.1,0.2) in UnitDisk()\ntrue\n\njulia> 0.5+0.2im ∈ ComplexUnitDisk()\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"UnitBall itself is an abstract type, hence the examples above return concrete types <:UnitBall. The types are similar to those associated with UnitSphere. Like intervals, balls can also be open or closed:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> EuclideanUnitBall{3,Float64,:open}()\nthe 3-dimensional open unit ball","category":"page"},{"location":"examples/#Product-domains","page":"Examples","title":"Product domains","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The cartesian product of domains is constructed with the ProductDomain or ProductDomain{T} constructor. This abstract constructor returns concrete types best adapted to the arguments given.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If T is not given, ProductDomain makes a suitable choice based on the arguments. If all arguments are Euclidean, i.e., their element types are numbers or static vectors, then the product is a Euclidean domain as well:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> ProductDomain(0..2, UnitCircle())\n0.0..2.0 x the unit circle\n\njulia> eltype(ans)\nSVector{3, Float64} (alias for SArray{Tuple{3}, Float64, 1, 3})","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The elements of the interval and the unit circle are flattened into a single vector, much like the vcat function. The result is a VcatDomain.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If a Vector of domains is given, the element type is a Vector as well:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> 1:5 in ProductDomain([0..i for i in 1:5])\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In other cases, the points are concatenated into a tuple and membership is evaluated element-wise:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> (\"a\", 0.4) ∈ ProductDomain([\"a\",\"b\"], 0..1)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some arguments are recognized and return a more specialized product domain. Examples are the unit box and more general hyperrectangles:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> ProductDomain(UnitInterval(), UnitInterval())\n0.0..1.0 (Unit) x 0.0..1.0 (Unit)\n\njulia> ProductDomain(0..2, 4..5, 6..7.0)\n0.0..2.0 x 4.0..5.0 x 6.0..7.0\n\njulia> typeof(ans)\nRectangle{SVector{3, Float64}}","category":"page"},{"location":"examples/#Union,-intersection,-and-setdiff-of-domains","page":"Examples","title":"Union, intersection, and setdiff of domains","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Domains can be unioned and intersected together:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> d = UnitCircle() ∪ 2UnitCircle();\n\njulia> in.([SVector(1,0),SVector(0,2), SVector(1.5,1.5)], d)\n3-element BitArray{1}:\n 1\n 1\n 0\n\njulia> d = UnitCircle() ∩ (2UnitCircle() .+ SVector(1.0,0.0))\nthe intersection of 2 domains:\n\t1.\t: the unit circle\n\t2.\t: A mapped domain based on the unit circle\n\njulia> SVector(1,0) in d\nfalse\n\njulia> SVector(-1,0) in d\ntrue","category":"page"},{"location":"examples/#Level-sets","page":"Examples","title":"Level sets","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A domain can be defined by the level sets of a function. The domains of all points [x,y] for which x*y = 1 or x*y >= 1 are represented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> d = LevelSet{SVector{2,Float64}}(prod, 1.0)\nlevel set f(x) = 1.0 with f = prod\n\njulia> [0.5,2] ∈ d\ntrue\n\njulia> SuperlevelSet{SVector{2,Float64}}(prod, 1.0)\nsuperlevel set f(x) >= 1.0 with f = prod","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There is also SublevelSet, and there are the special cases ZeroSet, SubzeroSet and SuperzeroSet.","category":"page"},{"location":"examples/#Indicator-functions","page":"Examples","title":"Indicator functions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A domain can be defined by an indicator function or a characteristic function. This is a function f(x) which evaluates to true or false, depending on whether or not the point x belongs to the domain.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> d = IndicatorFunction{Float64}( t ->  cos(t) > 0)\nindicator domain defined by function f = #5\n\njulia> 0.5 ∈ d, 3.1 ∈ d\n(true, false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This enables generator syntax to define domains:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> d = Domain(x>0 for x in -1..1)\nindicator function bounded by: -1..1\n\njulia> 0.5 ∈ d, -0.5 ∈ d\n(true, false)\n\njulia> d = Domain( x*y > 0 for (x,y) in UnitDisk())\nindicator function bounded by: the 2-dimensional closed unit ball\n\njulia> [0.2, 0.3] ∈ d, [0.2, -0.3] ∈ d\n(true, false)\n\njulia> d = Domain( x+y+z > 0 for (x,y,z) in ProductDomain(UnitDisk(), 0..1))\nindicator function bounded by: the 2-dimensional closed unit ball x 0..1\n\njulia> [0.3,0.2,0.5] ∈ d\ntrue","category":"page"},{"location":"#DomainSets.jl","page":"Home","title":"DomainSets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DomainSets.jl is a package designed to represent simple infinite sets. The package makes it easy to represent sets, verify membership of the set, compare sets and construct new sets from existing ones. Domains are considered equivalent if they describe the same set, regardless of their type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Get started quickly by looking at the Examples.","category":"page"},{"location":"#What-is-a-domain?","page":"Home","title":"What is a domain?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A domain is a continuous set of elements. Typical examples are geometrical shapes such as cubes and triangles, see Euclidean geometry. One can construct new sets from existing ones as unions and intersections, see Set operations. Domains can be combined this way regardless of their types, see The domain interface.","category":"page"}]
}
